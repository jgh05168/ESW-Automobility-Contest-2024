///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : inference.cpp
/// SOFTWARE COMPONENT NAME           : Inference
/// GENERATED DATE                    : 2024-11-07 14:01:17
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "inference/aa/inference.h"
#include "inference/aa/intel_inference_eng.hpp"
/// Intel Open Vino specific headers
// #include "ie_plugin_dispatcher.hpp"
// #include "ie_plugin_ptr.hpp"
// #include "cpp/ie_cnn_net_reader.h"
// ROS2 message headers
#include "deepracer_interfaces_pkg/msg/infer_results.hpp"
#include "deepracer_interfaces_pkg/msg/infer_results_array.hpp"

#include <exception>
#define RAD2DEG(x) ((x)*180./M_PI)

// opencv header. => 추후 딥레이서에 설치되어있는지 확인해봐야할듯 ? => 설치했다고 답변받음
#include <opencv2/opencv.hpp>
#include <vector>


const std::string LIDAR = "LIDAR";
const std::string STEREO = "STEREO_CAMERAS";
const std::string FRONT = "FRONT_FACING_CAMERA";
const std::string OBS = "observation";
const std::string LEFT = "LEFT_CAMERA";

 
namespace inference
{
namespace aa
{


/* 여기서부터 intel_inference_eng.cpp 가져오기 */

namespace {
    class InferenceExcept : public std::exception
    {
    /// Simple exception class that is used to send a message to the catch clause.
    public:
        /// @param msg Message to be logged
        InferenceExcept(std::string msg)
          : msg_(msg)
        {
        }
        virtual const char* what() const throw() override {
            return msg_.c_str();
        }
    private:
        /// Store message in class so that the what method can dump it when invoked.
        const std::string msg_;
    };
     /// Helper method that loads the multi head model into the desired plugin.
     /// @returns Inference request object that will be used to perform inference
     /// @param artifactPath Path to the artifact (xml) file
     /// @param device String value of the device being used (CPU/GPU)
     /// @param core Reference to a InferenceEngine core object.
     /// @param inputName Reference to the vector of input layer names
     /// @param outputName Reference to the output layers name, the method will populate this string
     /// @param inputPrec The precision to use for the input layer
     /// @param outputPrec The precision to use for the output layer
     InferenceEngine::InferRequest setMultiHeadModel(std::string artifactPath, const std::string &device,
                                            InferenceEngine::Core core, std::vector<std::string> &inputNamesArr,
                                            std::string &outputName, const InferenceEngine::Precision &inputPrec,
                                            const InferenceEngine::Precision &outputPrec,) {

        // Validate the artifact path.
        auto strIdx = artifactPath.rfind('.');
        if (strIdx == std::string::npos) {
            throw InferenceExcept("Artifact missing file extension");
        }
        if (artifactPath.substr(strIdx+1) != "xml") {
            throw InferenceExcept("No xml extension found");
        }

        auto network = core.ReadNetwork(artifactPath);
        // Loop through the inputNamesArr and set the precision
        for (const auto& pair : network.getInputsInfo()) {
            if(pair.first.rfind(OBS) != std::string::npos
               || pair.first.rfind(LIDAR) != std::string::npos
               || pair.first.rfind(FRONT) != std::string::npos
               || pair.first.rfind(STEREO) != std::string::npos
               || pair.first.rfind(LEFT) != std::string::npos) {
                inputNamesArr.push_back(pair.first);
                pair.second->setPrecision(inputPrec);
            }
        }
        auto outputInfo = network.getOutputsInfo().begin()->second;
        outputName = network.getOutputsInfo().begin()->first;
        outputInfo->setPrecision(outputPrec);

        auto executableNetwork = core.LoadNetwork(network, device);
        return executableNetwork.CreateInferRequest();
    }

    /// Helper method that loads grey images into the inference engine input
    /// @param inputPtr Pointer to the input data.
    /// @param imgProcessPtr Pointer to the image processing algorithm.
    /// @param imgData ROS message containing the image data.
    /// @param params Hash map of relevant parameters for image processing.
    template<typename T, typename V> void load1DImg(V *inputPtr,
                                                    cv::Mat &retImg,
                                                    std::shared_ptr<InferTask::ImgProcessBase> imgProcessPtr,
                                                    const sensor_msgs::msg::Image &imgData,
                                                    const std::unordered_map<std::string, int> &params) {
    imgProcessPtr->processImage(imgData, retImg, params);
    if (retImg.empty()) {
        throw InferenceExcept("No image after pre-process");
    }
    int height = retImg.rows;
    int width = retImg.cols;

    for (int  h = 0; h < height; h++) {
        for (int w = 0; w < width; w++) {
            inputPtr[h * width + w] = retImg.at<T>(h, w);
        }
    }
    }

    /// Helper method that loads multi channel images into the inference engine input
    /// @param inputPtr Pointer to the input data.
    /// @param imgProcessPtr Pointer to the image processing algorithm.
    /// @param imgData ROS message containing the image data.
    /// @param params Hash map of relevant parameters for image processing.
    template<typename T, typename V> void loadStackImg(V *inputPtr,
                                                    cv::Mat &retImg, 
                                                    std::shared_ptr<InferTask::ImgProcessBase> imgProcessPtr,
                                                    const sensor_msgs::msg::Image &imgData,
                                                    const std::unordered_map<std::string, int> &params) {
        imgProcessPtr->processImage(imgData, retImg, params);
        if (retImg.empty()) {
            throw InferenceExcept("No image after-pre process");
        }
        const int channelSize = retImg.rows * retImg.cols;

        for (size_t pixelNum = 0; pixelNum < channelSize; ++pixelNum) {
            for (size_t ch = 0; ch < retImg.channels(); ++ch) {
            inputPtr[(ch*channelSize) + pixelNum] = retImg.at<T>(pixelNum)[ch];
            }
        }
    }

    /// Helper method that loads multi channel images into the inference engine input
    /// @param inputPtr Pointer to the input data.
    /// @param imgProcessPtr Pointer to the image processing algorithm.
    /// @param imgData ROS message containing the image data.
    /// @param params Hash map of relevant parameters for image processing.
    template<typename T, typename V> void loadStereoImg(V *inputPtr,
                                                    cv::Mat &retImg, 
                                                    std::shared_ptr<InferTask::ImgProcessBase> imgProcessPtr,
                                                    const deepracer::service::fusiondata::proxy::methods::FMethod::Output& output,
                                                    const std::unordered_map<std::string, int> &params) {

    imgProcessPtr->processImageVec(output, retImg, params);
    if (retImg.empty()) {
        throw InferenceExcept("No image after-pre process");
    }
    
    const int width = retImg.cols;
    const int height = retImg.rows;
    const int channel = retImg.channels();

    for (int c = 0; c < channel; c++) {
        for (int  h = 0; h < height; h++) {
            for (int w = 0; w < width; w++) {
                inputPtr[c * width * height + h * width + w] = retImg.at<T>(h, w)[c];
            }
        }
    }
    }

    /// Helper method that loads 1D data into the inference engine input
    /// @param inputPtr Pointer to the input data.
    /// @param lidarData ROS message containing the lidar data.
    void loadLidarData(float *inputPtr,
                    const deepracer::service::fusiondata::proxy::methods::FMethod::Output& output) {
    size_t pixelNum = 0;
    for(const auto& lidar_value : output.fusion_data.lidar_data) {
        inputPtr[pixelNum] = lidar_value;
        ++pixelNum;
    }
    }
}


namespace IntelInferenceEngine {
    // RLInferenceModel::RLInferenceModel(std::shared_ptr<rclcpp::Node> inferenceNodePtr, const std::string &sensorSubName)
    //  : doInference_(false)
    // {
    //     inferenceNode = inferenceNodePtr;
    //     RCLCPP_INFO(inferenceNode->get_logger(), "Initializing RL Model");
    //     RCLCPP_INFO(inferenceNode->get_logger(), "%s", sensorSubName.c_str());
    //     // Subscribe to the sensor topic and set the call back
    //     sensorSub_ = inferenceNode->create_subscription<deepracer_interfaces_pkg::msg::EvoSensorMsg>(sensorSubName, 10, std::bind(&IntelInferenceEngine::RLInferenceModel::sensorCB, this, std::placeholders::_1));
    //     resultPub_ = inferenceNode->create_publisher<deepracer_interfaces_pkg::msg::InferResultsArray>("rl_results", 1);
    // }

    // RLInferenceModel::~RLInferenceModel() {
    //     stopInference();
    // }

    bool RLInferenceModel::loadModel(const char* artifactPath,
                            std::shared_ptr<InferTask::ImgProcessBase> imgProcess) {
        if (!imgProcess) {
            // RCLCPP_ERROR(inferenceNode->get_logger(), "Invalid image processing algorithm");
            return false;
        }
        // Set the image processing algorithms
        imgProcess_ = imgProcess;
        // Load the model
        try {
            inferRequest_ = setMultiHeadModel(artifactPath, "CPU", core_, inputNamesArr_,
                                     outputName_, InferenceEngine::Precision::FP32,
                                     InferenceEngine::Precision::FP32);
            for(size_t i = 0; i != inputNamesArr_.size(); ++i) {
                auto input = inferRequest_.GetBlob(inputNamesArr_[i]);
                std::unordered_map<std::string, int> params_ = {{"width", input->getTensorDesc().getDims()[3]},
                       {"height", input->getTensorDesc().getDims()[2]},
                       {"channels", input->getTensorDesc().getDims()[1]}};
                paramsArr_.push_back(params_);
            }
        }
        catch (const std::exception &ex) {
            // RCLCPP_ERROR(inferenceNode->get_logger(), "Model failed to load: %s", ex.what());
            return false;
        }
        return true;
    }

    void RLInferenceModel::startInference() {
        // Reset the image processing algorithm.
        if (imgProcess_) {
            imgProcess_->reset();
        }
        // doInference_ = true;
    }

    // void RLInferenceModel::stopInference() {
    //     doInference_ = false;
    // }

    void RLInferenceModel::sensorCB(const deepracer::service::fusiondata::proxy::methods::FMethod::Output& output) {
        try {
            for(size_t i = 0; i < inputNamesArr_.size(); ++i) {
                auto inputPtr = inferRequest_.GetBlob(inputNamesArr_[i])->buffer().as<InferenceEngine::PrecisionTrait<InferenceEngine::Precision::FP32>::value_type *>();

                /*
                deepracer_interfaces_pkg::msg::EvoSensorMsg::
                */

                // Object that will hold the data sent to the inference engine post processed.
                cv::Mat retData;
                if (inputNamesArr_[i].find(STEREO) != std::string::npos)
                {
                    loadStereoImg<cv::Vec2b, float>(inputPtr, retData, imgProcess_, output, paramsArr_[i]);
                }
                else if (inputNamesArr_[i].find(FRONT) != std::string::npos
                          || inputNamesArr_[i].find(LEFT) != std::string::npos
                          || inputNamesArr_[i].find(OBS) != std::string::npos) {
                    load1DImg<uchar, float>(inputPtr, retData, imgProcess_, output, paramsArr_[i]);
                }
                else if (inputNamesArr_[i].find(LIDAR) != std::string::npos){
                    loadLidarData(inputPtr, output);
                }
                else {
                    // RCLCPP_ERROR(inferenceNode->get_logger(), "Invalid input head");
                    return;
                }
                imgProcess_->reset();
            }
            // Do inference
            inferRequest_.Infer();

            auto output = inferRequest_.GetBlob(outputName_);
            // Package the results and publish to all subscribers.
            
            auto outputDims = output->getTensorDesc().getDims();
            auto outputData = output->buffer().as<InferenceEngine::PrecisionTrait<InferenceEngine::Precision::FP32>::value_type*>();

            auto inferMsg = deepracer_interfaces_pkg::msg::InferResultsArray();
            for (size_t i = 0; i < msg->images.size(); ++i) {
                // Send the image data over with the results
                inferMsg.images.push_back(msg->images[i]) ;
            }

            for (size_t label = 0; label < outputDims[1]; ++label) {
                auto inferData = deepracer_interfaces_pkg::msg::InferResults();
                inferData.class_label = label;
                inferData.class_prob = outputData[label];
                // Set bounding box data to -1 to indicate to subscribers that this model offers no
                // localization information.
                inferData.x_min = -1.0;
                inferData.y_min = -1.0;
                inferData.x_max = -1.0;
                inferData.y_max = -1.0;
                inferMsg.results.push_back(inferData);
            }
            // Send results to all subscribers.
            // resultPub_->publish(inferMsg);
            // 이 아래에 navigate로 Event를 보내는 코드 작성 ( 수정 필요 )
            
            /*
            
            */
        }
        catch (const std::exception &ex) {
            // RCLCPP_ERROR(inferenceNode->get_logger(), "Inference failed %s", ex.what());
        }
    }
}

/* 여기 이후로부터는 자동 빌드된 AA 코드 */
 
Inference::Inference()
    : m_logger(ara::log::CreateLogger("INFR", "SWC", ara::log::LogLevel::kVerbose)) // Logger 객체 초기화
    , m_workers(2)  // Run() 함수에서 m_workers.Async에 등록가능한 함수 갯수
{
}
 
Inference::~Inference()
{
}
 
bool Inference::Initialize()
{
    m_logger.LogVerbose() << "Inference::Initialize";
    
    bool init{true};

    // fusion PPort data
    m_FusionData = std::make_shared<inference::aa::port::FusionData>();
    // inference RPort data
    m_InferenceData = std::make_shared<inference::aa::port::InferenceData>();
    

    return init;
}
 
// 컴포넌트 시작 함수
void Inference::Start()
{
    m_logger.LogVerbose() << "Inference::Start";
    
    m_FusionData->Start();
    m_InferenceData->Start();
    
    // run software component
    Run();
}
 
// 컴포넌트 종료 함수
void Inference::Terminate()
{
    m_logger.LogVerbose() << "Inference::Terminate";
    
    m_FusionData->Terminate();
    m_InferenceData->Terminate();
}

// 컴포넌트 수행 함수
void Inference::Run()
{
    m_logger.LogVerbose() << "Inference::Run";
    
    // 모델 불러오기 ( 수정 필요 )
    // inference_node.cpp 132번째 줄 확인
    m_Inference = std::make_shared<inference::aa::IntelInferenceEngine::RLInferenceModel>();
    

    // 매 주기마다 IEvent 데이터를 전송
    m_workers.Async([this] { m_InferenceData->SendEventIEventCyclic(); });
    /*
    inference에서 처리해야 할 일
    1. Fusion에서 데이터 수신 : TaskRequestFMethod()
        1-2. Fusion 측에 Method 요청
    2. 요청 받으면 모델 판별 시작   
    3. Navigator에 데이터 송신 : SendEventIEventCyclic()
    */
    
    /*
    실행 순서 : 
    Run() -> TaskRequestFMethod() -> Response 처리 핸들러(SetReceiveMethodFMethodHandler) 등록
        -> RequestFMethod() -> 데이터 받았으면, OnReceiveFMethod() -> 모델 추론 -> WriteDataIEvent()
    */

    m_workers.Async([this] {TaskRequestFMethod(); });

    
    m_workers.Wait();
}


// FusionData에 대한 요청
void Inference::TaskRequestFMethod()
{
    // FMethod 핸들러 등록
    m_FusionData->SetReceiveMethodFMethodHandler([this](const auto& output)
    {
        // 여기서 output은 Camera & Lidar 정보를 담는 구조체
        OnReceiveFMethod(output);
    })


    // Fusion Data 요청
    m_logger.LogInfo() << "Inference::RequestFMethod (sensorfusion)";
    m_FusionData->RequestFMethod(deepracer::type::SensorFusionNode)
    
}


// Fusion FMethod에 대한 Response를 받았을시의 처리 함수
void Inference::OnReceiveFMethod(const deepracer::service::fusiondata::proxy::methods::FMethod::Output& output)
{
    // 추론 시작 ( 수정 필요 )
    m_Inference->startInference();

    m_logger.LogInfo() << "Inference::OnReceiveFMethod:" << output.fusion_data;


    // 데이터 전처리
    m_Inference->sensorCB(output);

    // 모델 추론 ( 수정 필요 )
    // loadModel(모델 경로, 처리된 이미지)
    // loadModel의 경우, inference_node.cpp에서 먼저 처리한다. 이 부분 다시 파봐야할듯함
    m_Inference->loadModel("", );


}


} /// namespace aa
} /// namespace inference
